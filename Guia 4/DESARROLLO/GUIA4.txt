---------------------------------------------------------------
-- CASO 2
---------------------------------------------------------------

DECLARE 
    CURSOR c1 IS 
        SELECT ID_EMP, NUMRUN_EMP, 
        DVRUN_EMP, pnombre_emp ||' '|| SNOMBRE_EMP|| ' '|| APPATERNO_EMP|| ' '||
        APMATERNO_EMP as "nombre", 
        -- NOMBRE USUARIO
        LOWER(SUBSTR(NOMBRE_ESTADO_CIVIL,0,1)) || SUBSTR(pnombre_emp,0,3)  || LENGTH(pnombre_emp) || '*' || SUBSTR(SUELDO_BASE,-1,1) || DVRUN_EMP  ||
        TRUNC(MONTHS_BETWEEN(SYSDATE,FECHA_CONTRATO)/12) as "nombre_usuario",
        -- CONTRASENIA
        SUBSTR(NUMRUN_EMP,3,1) || TO_NUMBER(TO_CHAR(FECHA_NAC,'YYYY') ) + 2 ||SUBSTR((SUELDO_BASE - 1),-3,3) ||
        
        CASE ec.ID_ESTADO_CIVIL
            WHEN 60 THEN LOWER(substr(APPATERNO_EMP,0,2))
            WHEN 10 THEN LOWER(substr(APPATERNO_EMP,0,2)) -- OK
            WHEN 20 THEN LOWER(substr(APPATERNO_EMP,0,1) ||  substr(APPATERNO_EMP,-1,1))-- 
            WHEN 30 THEN LOWER(substr(APPATERNO_EMP,0,1) ||  substr(APPATERNO_EMP,-1,1))-- OK
            WHEN 40 THEN LOWER(substr(APPATERNO_EMP,-3,2)) -- OK 
            WHEN 50 THEN LOWER(substr(APPATERNO_EMP,-2,2))  
            ELSE
                'X'
        END || ID_EMP AS "clave_usuario",
        -- ANIOS
        TRUNC(MONTHS_BETWEEN(SYSDATE,FECHA_CONTRATO)/12) AS "anios"
        FROM empleado e
        INNER JOIN ESTADO_CIVIL ec
        ON e.ID_ESTADO_CIVIL = ec.ID_ESTADO_CIVIL;
        
        -- Registros
        reg_c1 c1%rowtype;
        reg_usuario USUARIO_CLAVE%rowtype;
        
BEGIN

    -- TRUNCAR LA TABLA EN TIEMPO DE EJECUCION
    EXECUTE IMMEDIATE 'TRUNCATE TABLE USUARIO_CLAVE';    
    
    :b_fecha_proceso := '&dia' ||'/'||'&mes'||'/'||'&anio';

    FOR reg_c1 IN c1
    LOOP
        -- Cálculos
        reg_usuario.ID_EMP := reg_c1.id_emp;
        reg_usuario.NUMRUN_EMP := reg_c1.NUMRUN_EMP;
        reg_usuario.DVRUN_EMP := reg_c1.DVRUN_EMP;
        reg_usuario.NOMBRE_EMPLEADO := reg_c1."nombre";
        reg_usuario.NOMBRE_USUARIO := reg_c1."nombre_usuario";
        reg_usuario.CLAVE_USUARIO := reg_c1."clave_usuario" || TO_CHAR(TO_DATE(:b_fecha_proceso),'MMYYYY');
        
        IF TO_NUMBER(reg_c1."anios") < 10 THEN
        -- NOMBRE USUARIO
             reg_usuario.NOMBRE_USUARIO := reg_usuario.NOMBRE_USUARIO || 'X';
        END IF;
        
        -- Objetivo
        INSERT INTO USUARIO_CLAVE VALUES reg_usuario;
        COMMIT;
    END LOOP;
END;
/

--------------------------------------
-- CASO 3 
--------------------------------------

/*

    VALOR DEL PORCENTAJE 22.5

*/
-- POBLAR LA TABLA HIST_ARRIENDO_ANUAL_CAMION


-- PERMITE IMPRIMIR AUTOMÁTICAMENTE EL VALOR DE LA VARIABLE BIND
SET AUTOPRINT ON;

-- SALIDA DE DBMS
SET SERVEROUTPUT ON;

-- VARIABLE BIND
VARIABLE b_fecha_proceso VARCHAR2(10);

EXEC :B_FECHA_PROCESO := '01/01/2022';

-- REALIZAMOS UN RESPALDO DE LA TABLA CAMIÓN
DROP TABLE CAMION_BK;
CREATE TABLE CAMION_BK AS SELECT * FROM CAMION;

DECLARE
    
    -- CURSOR
    CURSOR C_CAMION IS
        SELECT ID_CAMION, NRO_PATENTE, 
        VALOR_ARRIENDO_DIA, VALOR_GARANTIA_DIA
        FROM CAMION;
    
    -- REGISTROS
    REG_C_CAMION C_CAMION%ROWTYPE;
    REG_RESUMEN HIST_ARRIENDO_ANUAL_CAMION%ROWTYPE;
    
    -- SQL DINÁMICO
    v_sql VARCHAR2(200);
    
    -- ACTUALIZAR VALOR ARRIENDO DIA Y VALOR GARANTIA DIA
    TYPE tipo_valor IS VARRAY(2) OF NUMBER(10) ;
    
    v_arreglo_valor tipo_valor :=  tipo_valor(0,0);
    
    -- PORCENTAJE
    v_pct_arriendo NUMBER(5,3) DEFAULT &porcentaje;
    
BEGIN
    
    -- RESTAMOS UN AÑO A LA FECHA DE PROCESO PARA PROCESAR LOS ARRIENDOS DEL AÑO PASADO
    :b_fecha_proceso := ADD_MONTHS(TO_DATE(:b_fecha_proceso),-12); 

    
    -- TRUNCAMIENTO EN TIEMPO DE EJECUCIÓN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE HIST_ARRIENDO_ANUAL_CAMION';
    COMMIT;

    FOR reg_c_camion IN C_CAMION 
    LOOP
        BEGIN
    
            -- CÁLCULOS
            
            reg_resumen.ANNO_PROCESO := TO_NUMBER(TO_CHAR(TO_DATE(:b_fecha_proceso),'YYYY'));
            reg_resumen.ID_CAMION := reg_c_camion.id_camion;
            reg_resumen.NRO_PATENTE := reg_c_camion.nro_patente;
            reg_resumen.VALOR_ARRIENDO_DIA := reg_c_camion.VALOR_ARRIENDO_DIA;
            reg_resumen.VALOR_GARACTIA_DIA := reg_c_camion.VALOR_GARANTIA_DIA;
    
            
            -- CALCULAR EL TOTAL DE ARRIENDOS
            BEGIN
                v_sql := 'SELECT COUNT(ID_ARRIENDO)
                FROM ARRIENDO_CAMION
                WHERE TO_CHAR(FECHA_INI_ARRIENDO, ''YYYY'') = TO_CHAR(:1,''YYYY'') AND ID_CAMION = :2
                GROUP BY id_camion';
                
                EXECUTE IMMEDIATE v_sql 
                INTO REG_RESUMEN.TOTAL_VECES_ARRENDADO
                USING TO_DATE(:b_fecha_proceso), reg_resumen.ID_CAMION;
                
                
            EXCEPTION
                WHEN OTHERS THEN
                    DBMS_OUTPUT.PUT_LINE('No se han solicitado arriendos para este camión.');
                    reg_resumen.TOTAL_VECES_ARRENDADO:= 0;
            END;
            
            -- SÓLO CONSIDERAMOS LOS CAMIONES QUE FUERON ARRENDADOS MENOS DE 4 VECES AL AÑO
            IF reg_resumen.TOTAL_VECES_ARRENDADO < 4 THEN
                
                -- CÁCULOS DE CAMIÓN
                v_pct_arriendo := v_pct_arriendo / 100;   
                v_arreglo_valor(1) := REG_RESUMEN.VALOR_ARRIENDO_DIA - round(REG_RESUMEN.VALOR_ARRIENDO_DIA * v_pct_arriendo,0);
                v_arreglo_valor(2) := REG_RESUMEN.VALOR_GARACTIA_DIA - ROUND(REG_RESUMEN.VALOR_GARACTIA_DIA * v_pct_arriendo,0);
  
                -- ACTUALIZAR LA TABLA CAMIÓN
            
                UPDATE CAMION_BK SET VALOR_ARRIENDO_DIA = v_arreglo_valor(1), VALOR_GARANTIA_DIA = v_arreglo_valor(2) 
                WHERE ID_CAMION = reg_resumen.ID_CAMION;
                
            END IF;
            
            -- OBJETIVO
            
            -- INSERTAR EN LA TABLA HISTORIAL
            INSERT INTO HIST_ARRIENDO_ANUAL_CAMION VALUES REG_RESUMEN;
            
             
            COMMIT;
            
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Error en el cursor' || SQLERRM);
        END;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error en el bloque PLSQL' || SQLERRM);
END;
/

SELECT * FROM CAMION_BK;


---------------------------------------------------------------
-- CASO 4
---------------------------------------------------------------

-- AÑO DE PROCESO DEBE SER 2020
-- PORCENTAJE A INGRESAR 30%
-- SIMULAR GANANCIAS DE 200.000.000

DROP TABLE TRAMO_SUELDO_BASE;

CREATE TABLE TRAMO_SUELDO_BASE (
    id_tramo NUMBER(1) PRIMARY KEY,
    tramo_inf NUMBER(7) NOT NULL,
    tramo_sup NUMBER(7) NOT NULL,
    pct_bonif NUMBER(2) NOT NULL
);

-- INSERT DE LOS DATOS DE LA TABLA DE TRAMOS 
INSERT INTO TRAMO_SUELDO_BASE VALUES (1,320000,600000,35);
INSERT INTO TRAMO_SUELDO_BASE VALUES (2,600001,1300000,25);
INSERT INTO TRAMO_SUELDO_BASE VALUES (3,1300001,1800000,20);
INSERT INTO TRAMO_SUELDO_BASE VALUES (4,1800001,2200000,15);
INSERT INTO TRAMO_SUELDO_BASE VALUES (5,2200001,9000000,5);
COMMIT;

DECLARE 
    -- DECLARAMOS EL CURSOR
    CURSOR c1 IS
        SELECT id_Emp, sueldo_Base 
        FROM EMPLEADO;

    CURSOR c2 IS
        SELECT id_Emp, sueldo_Base 
        FROM EMPLEADO;
    
    -- REGISTROS
    REG_RESUMEN BONIF_POR_UTILIDAD%ROWTYPE;
    REG_C1 C1%ROWTYPE;

    -- PORCENTAJE
    v_pct NUMBER(5,3) DEFAULT &porcentaje;

    -- GANANCIAS DEL AÑO
    v_ganancia_anual NUMBER(9) DEFAULT &ganancia_anual;

    -- ARREGLO CON LAS GANANCIAS DIVIDIDAS EN TRAMOS
    TYPE tipo_ganancias IS VARRAY(5) OF NUMBER(9);

    v_arreglo_ganancias tipo_ganancias := tipo_ganancias(0,0,0,0,0);

    -- VARIABLES PARA CONTAR A LOS EMPLEADO POR TRAMO
    v_tramo number(1);
    
    TYPE tipo_contador IS VARRAY(5) OF NUMBER;
    
    v_contador tipo_contador := tipo_contador(0,0,0,0,0);
    
    -- Validador de distribuición de ganancias (FLAG)
    v_valida BOOLEAN default FALSE;

BEGIN
    
    :b_fecha_proceso := TO_DATE('&fecha');
    v_pct := v_pct / 100;

    -- OBTENEMOS EL 30% DE LAS GANANCIAS ANUALES PARA DISTRIBUIRLAS
    v_ganancia_anual := ROUND(v_ganancia_anual * v_pct,0);

    SELECT pct_bonif / 100 * v_ganancia_anual INTO v_arreglo_ganancias(1)
    FROM TRAMO_SUELDO_BASE 
    WHERE id_tramo = 1;

    SELECT pct_bonif / 100 * v_ganancia_anual INTO v_arreglo_ganancias(2)
    FROM TRAMO_SUELDO_BASE 
    WHERE id_tramo = 2;

    SELECT pct_bonif / 100 * v_ganancia_anual INTO v_arreglo_ganancias(3)
    FROM TRAMO_SUELDO_BASE 
    WHERE id_tramo = 3;

    SELECT pct_bonif / 100 * v_ganancia_anual INTO v_arreglo_ganancias(4)
    FROM TRAMO_SUELDO_BASE 
    WHERE id_tramo = 4;

    SELECT pct_bonif / 100 * v_ganancia_anual INTO v_arreglo_ganancias(5)
    FROM TRAMO_SUELDO_BASE 
    WHERE id_tramo = 5;

    -- TRUNCADO EN TIEMPO DE EJECUCIÓN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE BONIF_POR_UTILIDAD';
    COMMIT;

    FOR REG_C1 IN C1 
    LOOP
        BEGIN
            
            -- Cálculos
            
            REG_RESUMEN.ANNO_PROCESO := TO_NUMBER(TO_CHAR(TO_DATE(:b_fecha_proceso),'YYYY'));
            REG_RESUMEN.ID_EMP := REG_C1.ID_EMP;
            REG_RESUMEN.SUELDO_BASE := REG_C1.SUELDO_BASE;

            -- INICIAMOS OTRO CURSOR QUE CUENTE A LOS EMPLEADOS POR TRAMO
            
            FOR x IN C2
            LOOP
                BEGIN
                    SELECT ID_TRAMO 
                    into v_tramo 
                    FROM tramo_sueldo_base WHERE x.sueldo_base BETWEEN tramo_inf AND tramo_sup;

                    IF v_tramo = 1 THEN
                    v_contador(1)  := v_contador(1) + 1;
                    ELSIF  v_tramo = 2 THEN 
                    v_contador(2) := v_contador(2) + 1;
                    ELSIF  v_tramo = 3 THEN  
                    v_contador(3) := v_contador(3) + 1;
                    ELSIF  v_tramo = 4 THEN 
                    v_contador(4) := v_contador(4) + 1;
                    ELSIF  v_tramo = 5 THEN 
                    v_contador(5) := v_contador(5) + 1;
                    END IF;

                EXCEPTION   
                WHEN OTHERS THEN    
                    DBMS_OUTPUT.PUT_LINE('Error en el 2do cursor');
                END;
            END LOOP;

            IF v_valida = FALSE THEN
                -- DISTRIBUIMOS LAS GANANCIAS
                v_arreglo_ganancias(1) := v_arreglo_ganancias(1) / v_contador(1);
                v_arreglo_ganancias(2) := v_arreglo_ganancias(2) / v_contador(2);
                v_arreglo_ganancias(3) := v_arreglo_ganancias(3) / v_contador(3);
                v_arreglo_ganancias(4) := v_arreglo_ganancias(4) / v_contador(4);
                v_arreglo_ganancias(5) := v_arreglo_ganancias(5) / v_contador(5);
                v_valida := TRUE;
            END IF;
            -- ASIGNAMOS LA GANANCIA CORRESPONDIENTE AL EMPLEADO
            SELECT 
            CASE ID_TRAMO
                WHEN 1 THEN v_arreglo_ganancias(1)
                WHEN 2 THEN v_arreglo_ganancias(2) 
                WHEN 3 THEN v_arreglo_ganancias(3)
                WHEN 4 THEN v_arreglo_ganancias(4)
                WHEN 5 THEN v_arreglo_ganancias(5)
            END 
            INTO REG_RESUMEN.VALOR_BONIF_UTILIDAD
            FROM tramo_sueldo_base 
            WHERE reg_resumen.sueldo_base 
            BETWEEN tramo_inf AND tramo_sup;


            -- Objetivo

            INSERT INTO BONIF_POR_UTILIDAD VALUES REG_RESUMEN;
            COMMIT;

        EXCEPTION 
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Error en el cursor.' || sqlerrm);
        END;
    END LOOP;

EXCEPTION  
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error en el bloque anónimo.' || SQLERRM);
END;
/





------------------------------------
-- CASO 5
------------------------------------



-- SIMULAR FECHA PROCESO 01/01/2023

CREATE SEQUENCE SEQ_INFO2 START WITH 10 INCREMENT BY 3;
CREATE SEQUENCE SEQ_INFO;
CREATE SEQUENCE SEQ_INFO3 START WITH 900 INCREMENT BY -10 MAXVALUE 900;


DECLARE
    -- DEFINIMOS EL CURSOR
    CURSOR c1 IS
        SELECT ID_EMP,
            TO_CHAR(NUMRUN_EMP,'999G999G999') || '-' ||DVRUN_EMP AS "rut",
            PNOMBRE_EMP || ' ' || SNOMBRE_EMP || ' ' || 
            APPATERNO_EMP || ' ' || APMATERNO_EMP as "nombre", 
            FECHA_CONTRATO, SUELDO_BASE, ID_COMUNA,
            COD_AFP, COD_TIPO_SAL
        FROM EMPLEADO;

    -- REGISTROS
    REG_C1 C1%ROWTYPE;
    REG_INFO INFO_SII%ROWTYPE;

    -- PORCENTAJE
    v_pct NUMBER(5,3);
    v_pct_afp NUMBER(5,3);
    v_pct_sal NUMBER(5,3);

    -- CANTIDAD DE CAMIONES ARRENDADOS
    v_cantidad_arr NUMBER(2);


BEGIN

    :b_fecha_proceso := ADD_MONTHS(TO_DATE('&FECHA_PROCESO'),-12);

    -- TRUNCAR EN TIEMPO DE EJECUCIÓN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE INFO_SII';

    -- CREAR SECUENCIA Y REINICIARLA POR EJECUCIÓN
    EXECUTE IMMEDIATE 'DROP SEQUENCE SEQ_INFO2';
    EXECUTE IMMEDIATE 'DROP SEQUENCE SEQ_INFO';
    EXECUTE IMMEDIATE 'DROP SEQUENCE SEQ_INFO3';
    EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_INFO';
    EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_INFO2 START WITH 10 INCREMENT BY 3';
    EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_INFO3 START WITH 900 INCREMENT BY -10 MAXVALUE 900';
    COMMIT;

    FOR REG_C1 IN C1
    LOOP
        BEGIN

            -- CÁLCULOS
            REG_INFO.ANNO_TRIBUTARIO := TO_CHAR(TO_DATE(:B_FECHA_PROCESO),'YYYY');
            REG_INFO.ID_EMP := REG_C1.ID_EMP;
            REG_INFO.RUN_EMPLEADO := TO_CHAR(seq_info.nextval,'09')||' '||REG_C1."rut"||SEQ_INFO2.nextval;
            REG_INFO.NOMBRE_EMPLEADO := REG_C1."nombre";

            -- OBTENEMOS LOS MESES TRABAJADOS
            REG_INFO.MESES_TRABAJADOS := TRUNC(MOD(MONTHS_BETWEEN(TO_DATE(:b_fecha_proceso),REG_C1.FECHA_CONTRATO),12));
            REG_INFO.ANNOS_TRABAJADOS := TRUNC(MONTHS_BETWEEN(TO_DATE(:b_fecha_proceso),REG_C1.FECHA_CONTRATO)/12);
            REG_INFO.SUELDO_BASE_MENSUAL := REG_C1.SUELDO_BASE || SEQ_INFO3.NEXTVAL;
            REG_INFO.SUELDO_BASE_ANUAL := REG_C1.SUELDO_BASE * 12;

            -- BONO ANTIGUEDAD
            BEGIN
                SELECT PORCENTAJE / 100 INTO v_pct
                FROM TRAMO_ANTIGUEDAD
                WHERE REG_INFO.ANNOS_TRABAJADOS 
                BETWEEN TRAMO_INF AND TRAMO_SUP 
                AND ANNO_VIG = TO_CHAR(TO_DATE(:b_fecha_proceso),'YYYY');
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    v_pct := 0;
            END;

            REG_INFO.BONO_ANNOS_ANUAL := ROUND(reg_info.SUELDO_BASE_ANUAL * v_pct,0);
            
            -- MOVILIZACIÓN 12% DEL SUELDO BASE DEL EMPLEADO
            REG_INFO.MOVILIZACION_ANUAL := ROUND(REG_INFO.SUELDO_BASE_ANUAL * 0.12,0);
            
            -- PAGO ADICIONAL A EMPLEADOS DE COMUNAS MÁS LEJANAS DE SANTIAGO

                /*
                María Pinto 117
Curacaví 118
Talagante 119
El Monte 120
Buin 121
                */
        
            IF REG_C1.id_comuna = 117 THEN
                REG_INFO.MOVILIZACION_ANUAL := REG_INFO.MOVILIZACION_ANUAL + round((REG_INFO.SUELDO_BASE_ANUAL * 0.2),0);
            ELSIF REG_C1.id_comuna = 118 THEN
                REG_INFO.MOVILIZACION_ANUAL := REG_INFO.MOVILIZACION_ANUAL + round((REG_INFO.SUELDO_BASE_ANUAL * 0.25),0);
            ELSIF REG_C1.id_comuna = 119 THEN
                REG_INFO.MOVILIZACION_ANUAL := REG_INFO.MOVILIZACION_ANUAL + round((REG_INFO.SUELDO_BASE_ANUAL * 0.30),0);
            ELSIF REG_C1.id_comuna = 120 THEN
                REG_INFO.MOVILIZACION_ANUAL := REG_INFO.MOVILIZACION_ANUAL + round((REG_INFO.SUELDO_BASE_ANUAL * 0.35),0);
            ELSIF REG_C1.id_comuna = 121 THEN
                REG_INFO.MOVILIZACION_ANUAL := REG_INFO.MOVILIZACION_ANUAL + round((REG_INFO.SUELDO_BASE_ANUAL * 0.40),0);
            END IF;
            

            -- COLACIÓN

            REG_INFO.COLACION_ANUAL := ROUND(REG_INFO.SUELDO_BASE_ANUAL * 0.2,0);
            
            -- DESCUENTOS POR AFP
            SELECT PORC_DESCTO_AFP / 100 INTO v_pct_afp
            FROM AFP 
            WHERE COD_AFP = REG_C1.COD_AFP;

            -- DESCUENTO POR SALUD
            SELECT PORC_DESCTO_SALUD / 100 INTO v_pct_sal
            FROM TIPO_SALUD
            WHERE COD_TIPO_SAL = REG_c1.COD_TIPO_SAL;

            REG_INFO.DESCTOS_LEGALES := ROUND(REG_INFO.SUELDO_BASE_ANUAL * v_pct_afp,0) + ROUND(REG_INFO.SUELDO_BASE_ANUAL * v_pct_SAL,0);
            
            REG_INFO.SUELDO_BRUTO_ANUAL := reg_info.SUELDO_BASE_ANUAL + REG_INFO.BONO_ANNOS_ANUAL + REG_INFO.MOVILIZACION_ANUAL + REG_INFO.COLACION_ANUAL;
            
                        
            -- OBTENERMOS EL CARGO
            BEGIN
                SELECT 'Encargado de Arriendos',count(id_camion) 
                into REG_INFO.CARGO, v_cantidad_arr
                FROM EMPLEADO E
                INNER JOIN CAMION C
                ON E.ID_EMP = C.ID_EMP
                WHERE E.ID_EMP = REG_INFO.ID_EMP
                group by 'Encargado de Arriendos';
                
                -- ES ENCARGADO DE ARRIENDOS 
                REG_INFO.BONO_ESPECIAL_ANUAL := ROUND(REG_INFO.SUELDO_BASE_ANUAL * ((v_cantidad_arr * 5) /100),0);
             
            EXCEPTION   
                WHEN NO_DATA_FOUND THEN
                    REG_INFO.CARGO := 'Labores Administrativas';

                    -- ES ENCARGADO DE LABORES ADMINISTRATIVAS
                    
                    -- X SUELDO BRUTO
                    REG_INFO.BONO_ESPECIAL_ANUAL := ROUND(REG_INFO.SUELDO_BRUTO_ANUAL * 0.12,0);
            END;
            
            /*
                o	sueldo base +
                 bono por años trabajados +
                  bono por arriendo de camiones +
                   bono por bienestar
                   – descuento salud –
                    descuento afp
            */
            -- IMPONIBLE ANUAL
            REG_INFO.RENTA_IMPONIBLE_ANUAL  := REG_INFO.SUELDO_BASE_ANUAL + REG_INFO.BONO_ANNOS_ANUAL 
            + REG_INFO.BONO_ESPECIAL_ANUAL + REG_INFO.DESCTOS_LEGALES;
            
            --OBJETIVO
            INSERT INTO INFO_SII VALUES REG_INFO;
            COMMIT;
        EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error en el cursor' || SQLERRM);
        END;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error en el bloque anónimo.' || SQLERRM);
END;
/